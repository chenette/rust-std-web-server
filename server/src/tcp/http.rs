// HttpRequest

// https://datatracker.ietf.org/doc/html/rfc9112#section-3
pub struct HttpRequestLine {
    pub method: String,
    pub url: String,
    pub version: String,
}

pub struct HttpRequestHeaderFields {
    pub headers: std::collections::HashMap<String, String>,
}

// Rename to just 'request' since we are already in the http file? Whatever approach we use, we will need to standardize across all files
pub struct HttpRequest {
    pub request_line: HttpRequestLine,
    pub header_fields: HttpRequestHeaderFields,
    pub body: Vec<u8>,
}

// HttpResponse
pub struct HttpResponseStatusLine {
    pub version: String,
    pub status_code: String,
    pub reason_phrase: String,
}

pub struct HttpResponseHeaderFields {
    pub version: String,
    pub status_code: String,
    pub reason_phrase: String,
}

pub struct HttpResponse {
    pub status_line: HttpResponseStatusLine,
    pub header_fields: HttpResponseHeaderFields,
    pub body: Vec<u8>,
}

// GENERATED BY COPILOT
impl HttpRequestHeaderFields {
    // Create a new instance of HttpRequestHeaderFields
    pub fn new() -> Self {
        HttpRequestHeaderFields {
            headers: std::collections::HashMap::new(),
        }
    }

    // Add a header field
    pub fn add_header(&mut self, key: String, value: String) {
        self.headers.insert(key, value);
    }

    // Remove a header field
    pub fn remove_header(&mut self, key: &str) {
        self.headers.remove(key);
    }

    // Get a header field
    pub fn get_header(&self, key: &str) -> Option<&String> {
        self.headers.get(key)
    }

    // Get all headers
    pub fn get_all_headers(&self) -> &std::collections::HashMap<String, String> {
        &self.headers
    }
}

// GENERATED BY COPILOT
// fn is_valid_http_request(request: &[u8]) -> bool {
// 	// Convert the request bytes to a string
// 	let request_str = match std::str::from_utf8(request) {
// 		Ok(str) => str,
// 		Err(_) => return false, // Invalid UTF-8, not a valid request
// 	};

// 	// Check if the request starts with "GET", "POST", "PUT", or "DELETE"
// 	if !request_str.starts_with("GET") && !request_str.starts_with("POST")
// 		&& !request_str.starts_with("PUT") && !request_str.starts_with("DELETE")
// 	{
// 		return false; // Not a valid request
// 	}

// 	// Check if the request ends with "\r\n\r\n" (indicating end of headers)
// 	if !request_str.ends_with("\r\n\r\n") {
// 		return false; // Not a valid request
// 	}

// 	// Additional validation logic can be added here if needed

// 	true // The request is valid
// }



// pub fn is_valid_http_1_1(supposed_http_request: &str) -> bool {
//     // https://datatracker.ietf.org/doc/html/rfc9112

//     let mut request_items: std::str::SplitWhitespace = supposed_http_request.split_whitespace();

//     while request_items.next() != None
//     {

//     }

//     // Method - https://datatracker.ietf.org/doc/html/rfc9112#section-3.1
//     // "The request method is case-sensitive."

//     return false;
// }

pub fn vec_u8_to_http_request(buffer: Vec<u8>) -> HttpRequest {
    // Take the Vec<u8> and turn it into a &str
    let str_to_split: &str = match std::str::from_utf8(buffer.as_slice()) {
        Ok(str) => str,
        Err(e) => panic!(
            "ERROR (VEC_U8_TO_HTTP_REQUEST): Invalid UTF-8: {}",
            e
        ),
    };

    // Verify that the request &str contains valid HTTP. Panic if otherwise.
    // assert!(is_valid_http_1_1(str_to_split));

    // Split new &str on whitespace. Would prefer regex here for validation and ease of use purposes.
    let mut request_items: std::str::SplitWhitespace = str_to_split.split_whitespace();

    let request_method: String = match request_items.next() {
        Some(str) => str.to_string(),
        None => panic!(
            "ERROR (CONSTRUCT_HTTP_REQUEST_FROM_VEC_U8): Unable to grab request method. Panicking!"
        ),
    };
    let request_url: String = match request_items.next() {
        Some(str) => str.to_string(),
        None => panic!(
            "ERROR (CONSTRUCT_HTTP_REQUEST_FROM_VEC_U8): Unable to grab request url. Panicking!"
        ),
    };
    let request_version: String = match request_items.next() {
        Some(str) => str.to_string(),
        None => panic!(
            "ERROR (CONSTRUCT_HTTP_REQUEST_FROM_VEC_U8): Unable to grab request version. Panicking!"
        ),
    };


    // Construct HttpRequestLine
    let request_line: HttpRequestLine = HttpRequestLine {
        method: request_method.clone(),
        url: request_url.clone(),
        version: request_version.clone(),
    };

    // Construct HttpRequestHeaderFields
    let mut header_fields: HttpRequestHeaderFields = HttpRequestHeaderFields::new();
    header_fields.add_header("Content-Type".to_string(), "application/json".to_string());
    header_fields.add_header("User-Agent".to_string(), "Mozilla/5.0".to_string());

    // Construct HttpRequest
    let http_request: HttpRequest = HttpRequest {
        request_line: request_line,
        header_fields: header_fields,
        body: Vec::new(),
    };
    println!("LOG (CONSTRUCT_HTTP_REQUEST_FROM_VEC_U8):\n   HttpRequest Constructed:\n      method: {}\n      url: {}\n      version: {}", http_request.request_line.method, http_request.request_line.url, http_request.request_line.version);
    http_request
}

pub fn construct_http_response(buffer: Vec<u8>) -> HttpResponse {
    let http_response: HttpResponse = HttpResponse {
        status_line: HttpResponseStatusLine {
            version: "HTTP/1.1".to_string(),
            status_code: "200".to_string(),
            reason_phrase: "OK".to_string(),
        },
        header_fields: HttpResponseHeaderFields {
            version: "HTTP/1.1".to_string(),
            status_code: "200".to_string(),
            reason_phrase: "OK".to_string(),
        },
        body: buffer,
    };
    http_response
}
